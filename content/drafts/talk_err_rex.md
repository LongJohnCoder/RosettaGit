+++
title = "Talk:$err.rex"
description = ""
date = 2016-05-10T06:25:51Z
aliases = []
[extra]
id = 20898
[taxonomies]
categories = []
tags = []
+++

== How does this fit here? ==

This does not seem to be a task - are you sure this is the right site for it? (I'm thinking maybe move it to another wiki and include a link there from your user page?) --[[User:Rdm|Rdm]] ([[User talk:Rdm|talk]]) 13:23, 9 May 2016 (UTC)

-----

I'm not understanding about a link to there from my user page.   How would that help? 

Why would a CBLF, er..., a person, looking at   '''a'''   Rosetta Code (REXX) solution/entry wander off to my user page   (assuming that they know who/what I am --- the author of the code, and I'm not one that puts my name on every [or any] REXX program that I enter), and then, from there, go off to another site to look at some code which may or may not explain or show the missing REXX code).   Ya, I know, they could always look it up in the "history" thingy, assuming that I entered/updated the correct section.   In my case, I almost always change the '''RUBY''' section, and then prepend the '''REXX''' section. 

Whenever I'm at a site that has those indirect and rather obtuse links, the links seem to be broken or not working in more cases than not.   And I can never quite trust those links, with all the cra... er, crud there is on those webpages. 


Anyway, addressing the issue at hand ---

The  $ERR (REXX) program is definitely not a solution to a specific Rosetta Code task --- at least, not directly.   I do think it belongs on Rosetta Code because of references (uses) of this REXX program by various other REXX programs (solutions) entered for solutions/problems/tasks on Rosetta Code.   I don't have the skills nor ability to create   ''another''   Wiki to move these few essential (my choice of words) support programs to it.   Each of these support programs also have a separate help (documentation) file, and it is separate for the same reasons.   [They also have other support documentation, specifically a logic flow and a sample use (usage) file which shows sample uses, but I thought that would be the straw that broke the camel's back here on Rosetta Code.]   The separate help files (possibly) aren't required, but I believe that more documentation is better then too little.   You can always ignore it, but if you need it, ... it's there, ... er, here, I mean.
  And it's not like you have to read or see it, it's only there if you go down the link chain, so to speak, a rabbit hole that you don't have to travel down.

By   ''rabbit hole'',   ya know, ya link to a page, then ya link to another page, then ...   

The $ERR (REXX) program is an external routine that other REXX programs on Rosetta Code make use of, those other REXX that are present on Rosetta Code and which do solve specific Rosetta Code problems (tasks).   Rather than having numerous copies of these commonly used REXX program(s) attached/affixed to those tasks, I've included them here since these "common-core" REXX routines make the other REXX programs useable and complete --- it is the idiomatic method that REXX programmers always used since the 1980's (oy veh, that does show my age).   This isn't the only occurrence of such a "helper" REXX program, but it was the only one that was previously renamed (or moved) and made other links to it invalid (i.e., broken links, a bane if I ever saw one, and I always interpret broken links as a symptom of a poorly maintained web site).   Since I didn't want to argue the point with someone who buys ink by the barrel, I left the broken links as they were for (quite) sometime, hoping the problem with be fixed by the "someone" who broke it in the first place.   It wasn't.   More fool, me.   (Adding a re-direct would've worked, but those thingys are a mystery to me, and I'm not sure that would solve the problem, and that's assuming that I have the authority and know-how to add/implement those re-directs thingys, possibly creating another rabbit hole).   So eventually, I made it consistent with the other (easy to understand) helper programs and reinstated it (with a new version that included better documentation (comments) and other such improvements, along with a comment to explain what it is and how ya gets to here (er, ... there).  

Normally, most of the (small) solutions to various Rosetta Code problems don't require these helper/assist REXX programs.   Or perhaps, a better way to express that is to say that I chose not to enter a more robust (and voluminous) REXX example.   But as the solutions get more complex and bulkier (and robust), and rather than including them with those solutions, the idiomatic method of handing these types of routine functions is to write an external routine (i.e., a REXX program) and just invoke that routine to perform some common (useful) service.

By the way, in case you don't know it, the REXX language (for instance), doesn't have any "higher" math functions, no trigonometric or hyperbolic functions, and it doesn't even have things like a square root (SQRT) function, so we REXX programs have to roll our own   (or borrow someone else's version).   Normally, the SQRT function would be included in another external routine, but here on Rosetta Code, that doesn't lend itself to that option, so it would just be easier to include the source within the REXX program that uses that function.   I just use the SQRT function as an example, and SQRT happens to be short enough that that technique is useable and feasible.

There is a whole 'nother back-story on that, and it lies in the roots of how REXX came to being, and how the original environment facilitated such external (REXX) programs for ease-of-use and performance issues.


For instance, issuing specific error or informational messages for the various REXX programs that do, in
fact, issue error messages because of interaction with a user (such as games, where incorrect or incomplete input is expected, and indeed, happens with common frequency) --- as in the case of games when there is a lot of interaction with a user (that is, a player or players).   Having these error message in an external routine makes the presentation of those messages external to the calling program and doesn't clutter up the program being presented at any specific Rosetta Code task.   The issuance of those error message just detracts from the solution (entry), and makes it pretty bulky.   Of what I've observed on Rosetta Code, most computer programmers don't handle errors at all, that is, they assume that the input(s) from the users/players are correct and without error.   (A utopia !!)   I don't subscribe to that philosophy.   If there is an interaction with the user (or player in some cases), there <u>will</u> almost certainly be errors.   Checking for those errors (or lack of input, misspellings, typos, wrong types of inputs, too little, too much, etc) really makes the programs more robust and not fail with some obscure (or ugh, general) error message.   This isn't just a problem with interpretative languages, but with input to solutions (computer programs) that aren't guaranteed to be perfect.   Now, some Rosetta Code tasks say (something to the effect) that to assume the input is correct   (if there is input data/numbers/integers (positive) to be processed).   With games and other interactive situations, not so much.


In the vein of wanting world peace ···

I wish there was something more of a guideline about entering "largish" Rosetta Code solutions (entries), that is, if a computer program is over a certain size (source lines), put the program into a separate section, diminishing the bulk of the Rosetta Code collection of entries.   I know this is a problem of most of the "popular" Rosetta Code tasks (popular = many entries = many lines of code = slow rendering = ···).   There appears (to me) too much code golf as it is, and entering a robust solution seems to be atypical, and even frowned upon to some degree -- at least, that's been my impression, unfortunately.   As you are probably aware, the REXX programs that I've entered contain a lot of comments, a commodity that should be encouraged, I should think.   In that vein, I reduce the size of the (some) REXX programs by having commonly-issued error message(s) in an external REXX program, along with the boilerplate code to help insure the user actually sees the error message(s)  [in color {red} if supported], and with the necessary auxiliary information such as what the error is (in the vernacular), where it occurred (which program, which line, which REXX variable --if that is appropriate), what action caused the error, etc.   Now, all this comes at a price.   Because of this bulk, is the main reason the external program exists, that, and the error recovery (flushing the stack, closing all open files, etc).   Now, this is just a routine to ensure the user actually sees the error (or informational) messages;   the $ERR REXX program in reality, uses another program ($T, in my case) that handles the situation of ensuring that there is a CONS (console) device and it is "enabled", along with the checking if the REXX interpreter and/or operating system (and terminal) supports color, and if so, uses a specific color if requested.   Yada, yada, yada.

Another case is the use of specific BIFs that may or may not be present in older (or newer, for that matter) REXXes.   The LINESIZE, SOUND, SLEEP, SCRSIZE, CHANGESTR, COUNTSTR, and various options for the DATE and TIME functions, etc, and others, which I don't include within the (host) REXX programs, but link to if the user wants (or needs) actual working code if their REXX interpreter doesn't have that facility (or BIF).   In actuality, all of my (regular, at home) REXX programs have a boilerplate epilog that determines which REXX (interpreter) is being used, what operating system it's running under, and sets/defines various "system" variables indicating what command to use to clear the terminal screen, what option to use to inquire/set environmental variables (the   ''pool''   name), handles any request for (help) documentation), and some other stuff that I won't bore ya with regarding error recovery and stuff like that there.   I really don't appreciate (REXX Rosetta Code, and in general) entries that make use of BIFs (or facilities) that aren't present in all REXXes.   This is one of the main reasons that I insisted that major deviations from Classic REXX have their own language category, otherwise it would be a Tower of Babel --- what would be the usefulness of having all the BASIC variants being lumped together, for instance?   But that is an old and practically dead horse that still comes up at times --- and a subject that I wish I could have with the powers-that-be. 


Yeah, I know, I know ··· 

Ya ask me what time it is, and I tell ya how to build a watch. -- [[User:Gerard Schildberger|Gerard Schildberger]] ([[User talk:Gerard Schildberger|talk]]) 19:50, 9 May 2016 (UTC)

: (1) For the same reason someone would stumble across this page in the first place (or stumble across one of the other [[Special:DeadendPages]]).
: (2) Github and Sourceforge and a variety of other sites offer free wiki implementations for all users. You can even have that hosted on a specific domain.
: (3) rexxla.org looks like it's trying to set up a wiki, also - you might try contacting them and [if they need technical help] we might be able to find someone to help with that.
: (4) As for language fragmentation in the task entries here - that's going to take some effort to resolve. But if it's worth doing it's worth spending some time on.
: Generally speaking, it's probably better to work with other people on efforts that lead in the direction you want to go, and then build on that... --[[User:Rdm|Rdm]] ([[User talk:Rdm|talk]]) 04:26, 10 May 2016 (UTC)

-----

The page in question isn't a dead-end page, it is pointed to (linked to) by those REXX entries that referenced (or, rather ''used'') that external routine.   Even if stumbled upon, they could, of course, read the comments at the top of the page stating what that page is used for (or used by).   They also could just click on the   '''What links here'''   at the bottom on almost all pages of this kind.

This doesn't work in this particular case because Rosetta Code says the file doesn't exist because it has been previously deleted.   But it '''does''' exist, it's just that it can't be   ''linked'' to correctly.   (Well, that's not true either, it can be linked to, but the "link" appears to be dead --- possibly because of a bad misdirect or some such odd thingy.)   So there ya have it in a nutshell.

So now, I have a dead link   (or maybe more correctly, an   ''ineffective''   link)   because of the previous action mentioned (<strike>previously,</strike> above, that is, the deletion or renaming of the file or the addition of some kind of redirection thingy).   I left the situation alone for some time, and now, trying to correct all the broken links, those links are still broken.   It seems that Rosetta Code (or some code) is getting in the way.   The code appears to be a dead-end as all the previous links to that page are essentially,
going to a dead page that exists, but can't be linked to because of something that says that the file has been previously deleted.   It is some weird catch-22 type of dead-link hell.

I'm not sure of the reasoning behind moving source code used on Rosetta Code to other Wikis, as this particular source code (program) already has two copies of the program (and still has broken links, but that is another issue to be resolved hopefully).   Links to this particular REXX program say the file doesn't exist   (because it has previously been deleted).   It's not like the REXX program has no connection to Rosetta Code, indeed, it's invoked directly by several (other) Rosetta Code (REXX) programs   (and has documentation that mentions/contain the links to this program).   This is beginning to feel like I'm pushing a chain uphill.   Everything was honky-dory until that REXX program (file/webpage) was deleted (and apparently, renamed in some manner). 

As far as that organization is concerned, (and, as far as I know, you have to be a paying member to post/store things there),   I have been mistreated by that organization and my some of my statements were taken out of context from a (familiar) private e-mail to a fellow REXXer (who happened to be a member) and misquoted (posted) there without my permission, and furthermore, my character, expertise and integrity has been slandered.   Indeed, that treatment has spilled over into Rosetta Code at one time (within a particular talk page).   In any case, I don't want to be any part of that organization for those reasons and others. 


You mentioned language fragmentation.   What is that exactly?   Are you talking about the different dialects, versions, and/or capabilities of the various computer programming languages?


As for the direction that I want to go ... I never thought about a <strike>formal</strike> written-out definition of it, but I just wanted to include (contained wholly on the Rosetta Code site) all (external) routines that are used (invoked) by any of the REXX programs that were written by me.   To put it another way, if there is REXX code included on Rosetta Code that executes REXX code, then include that source on Rosetta Code as well, preferably on a separate and unique page to make perusing easier.

  -- [[User:Gerard Schildberger|Gerard Schildberger]] ([[User talk:Gerard Schildberger|talk]]) 05:24, 10 May 2016 (UTC)

==error messages==
One of the many things people want to do with error messages and the like (or just plain ole informational text messages for that matter)   is to be able to have part (or all) of the message text in a specific color (such as in red or pink for error messages, yellow for warning messages, etc).   I put a lot of time and effort into writing a REXX external routine to do just that, and make it transparent and easy to use with whatever REXX interpreter (and operating system) was being used --- so that if color isn't supported, the message text still gets displayed.   The resulting REXX code   (named '''$T.REX''')   is pretty obtuse because it has to allow the external REXX code (routine) to run on many platforms (operating systems), and that generality takes its toll.   Not very pretty to read, but it's something that most programmers wanted to do, but didn't have the time or ability to program such a beast for general (or use in production) consumption.   I thought that routine was useful enough to include here on Rosetta code as an auxiliary file (support file), but not to include it as a solution (entry) to a specific (or too narrow) of, as yet, a non-existent Rosetta Code task, which I thought the task requirements would be too narrow of focus, and I have concerns already about how Rosetta Code draft tasks are promoted (or rather, not promoted).   One thing that I've noticed is that almost all computer programming language entries (on Rosetta Code) are mostly platform specific (almost all are assumed to be running ASCII computers), and also most of them running on a PC, some even specific to operating system(s).   When I include REXX solutions that also run on an EBCDIC system, I feel like a brown shoe at a tuxedo party.   Two big examples are the sorting order of ASCII and EBCDIC systems   (decimal digits, uppercase Latin alphabet, lowercase Latin alphabet for ASCII, and lowercase alphabet, uppercase alphabet, then decimal digits for EBCDIC).   Of course, most of the special characters are in a different order as well.   The other big example is that ASCII Latin letters (A──►Z, and also a──►z)  are contiguous in ASCII, but not in EBCDIC.   It takes some skill in knowing how to write code that is independent of the underlying hardware.   -- [[User:Gerard Schildberger|Gerard Schildberger]] ([[User talk:Gerard Schildberger|talk]]) 06:24, 10 May 2016 (UTC)
