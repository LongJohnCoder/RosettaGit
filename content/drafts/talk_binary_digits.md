+++
title = "Talk:Binary digits"
description = ""
date = 2013-01-19T18:31:11Z
aliases = []
[extra]
id = 10044
[taxonomies]
categories = []
tags = []
+++

== Has to be a dupe ==

[[Non-decimal radices/Convert]] and [[Non-decimal radices/Output]] cover both built-in functions and user-defined functions. I don't see how this can't be a duplicate. --[[User:Mwn3d|Mwn3d]] 17:29, 6 July 2011 (UTC)

:Ok: [[Non-decimal radices/Convert]] - This tasks involve conversion. The binary digits task does not necessarily involve conversion (unless this is required by the language)
:The [[Non-decimal radices/Output]] requires native support for binary without conversion. The binary digits task does not require native binary support and conversion is allowed.
:So this task is not a duplicate of either task[[User:Markhobley|Markhobley]] 17:40, 6 July 2011 (UTC)

:Binary, Octal, Hexadecimal and Decimal are special cases, because they are sometimes handled natively from within the language, and sometimes they are not. A conversion task is not ideal for tasks that have native support, and a requirement for native support is not ideal for languages that do not have such a facility. These bases require their own sets of tasks. [[User:Markhobley|Markhobley]] 17:43, 6 July 2011 (UTC)
::I don't understand the differences that you're talking about. "The results can be achieved using builtin radix functions within the language..." which is part of [[Non-decimal radices/Output]], "or a user defined function can be utilized" which is part of [[Non-decimal radices/Convert]]. Neither is exactly the same, but the parts are in both, and I don't see what this task adds to them. I need a better explanation of the differences. What would be better is a demonstration of this task in a language that is also implemented in both the other tasks. --[[User:Mwn3d|Mwn3d]] 17:48, 6 July 2011 (UTC)
::"With conversion", "without conversion", them are all just words.  What is a "conversion" exactly? Take an integer, give back a string, how is that not a conversion? Are decimal numbers stored inside the computer as digits 0-9, you think? --[[User:Ledrug|Ledrug]] 17:55, 6 July 2011 (UTC)

:::Right. I am talking about at language level, not CPU level here. Some languages allow a binary value to be used natively (from within the language). Other languages do not allow this (and therefore do not have binary support at a native language level). If the language does not have a radix specifier for binary (ie it does not have native support for binary), then we have to do some number crunching or string manipulation to derive the binary value as output. If a conversion routine does not need to be written within that language, because the language already supports this, we can say it handles binary "without conversion". If the language does not provide any native handling for binary, and we have to write some number crunching code, then this is a "conversion". Does that make sense? It will probably be clearer, when some of the conversion routines get pasted in.
:::[[User:Markhobley|Markhobley]] 18:15, 6 July 2011 (UTC)
::::For example: J has a special binary type, which is much like a boolean type in other languages, except that its values are 0 and 1 instead of true and false.  It's explicitly a numeric type.  And a binary number can be represented as a list whose members are this binary type.  Thus, the native representation of this type contains spaces (since that's how J represents numeric lists).  J also has a primitive to change a number into a binary lists and another primitive for the inverse operation.  So... in this context -- where the language has a type that corresponds to "binary digits" and another type that corresponds to "normal numbers" it can make sense to talk about conversion, no?  But I think the question is: what does this distinction mean when you do not have this kind of infrastructure?  --[[User:Rdm|Rdm]] 18:59, 6 July 2011 (UTC)

:::Also a conversion routine that handle several different number bases, may not be the best way to handle a conversion to binary. The routines in [[Non-decimal radices/Convert]] are probably best used in generic circumstances when the target base is not known at compile time. If we know we are going to require binary, then dedicated binary handling methods are best deployed. [[User:Markhobley|Markhobley]] 18:23, 6 July 2011 (UTC)
::::So exactly what is the goal, take a string of binary digits and produce a native number type? Or the other way around?  Your earlier explanation seems to go the opposite direction than the task description.  Also hex and oct handling share a lot similarities with binary, only decimal is the odd one. --[[User:Ledrug|Ledrug]] 18:28, 6 July 2011 (UTC)

:::::Given a decimal value n, produce its binary digits. Some languages will need to perform number crunching and string manipulation to achieve this. [[User:Markhobley|Markhobley]] 18:36, 6 July 2011 (UTC)
::::::Ok I assume when you say "decimal", you really mean "integer".  Now I'm curious, there is a language that doesn't need any ''computation'' or ''string manipulation'' to produce a ''string'' of binary digits? --[[User:Ledrug|Ledrug]] 18:41, 6 July 2011 (UTC)
:::::::Yes. Some languages can output binary numbers natively.[[User:Markhobley|Markhobley]] 19:22, 6 July 2011 (UTC)
::::::::Fundamentally, all languages that run on binary computers output binary numbers natively.  It's a matter of what they output those numbers to, and what constraints the language places on where it gets those binary numbers from.  ASCII is an example of direct binary output.  But that might not be what you meant? --[[User:Rdm|Rdm]] 19:39, 6 July 2011 (UTC)

::I still don't get it. From your task description, it seems that this task is basically: copy the example from [[Non-decimal radices/Output]] (conversion from decimal to special bases with special support from language) for binary in your language, and if it doesn't exist, then copy the example from [[Non-decimal radices/Convert]] (conversion from decimal to general bases, with or without special support from language) and make it for binary. All the examples currently on this page are duplicates of one of those two. I can't imagine how a solution for this task would NOT directly fall under one of those two tasks. --[[Special:Contributions/98.210.210.193|98.210.210.193]] 07:52, 7 July 2011 (UTC)
::: As it happens, the Tcl solution is one such. See, there may be some value after all! â€“[[User:Dkf|Donal Fellows]] 08:27, 7 July 2011 (UTC)
::: The ZX Spectrum Basic solution is also specifically designed for binary, so does not fall under [[Non-decimal radices/Convert]]. [[User:Markhobley|Markhobley]] 13:05, 7 July 2011 (UTC)
:::: As a friend of mine observed, the intent seems to be to implement a special-case of those other two tasks, without incurring the overhead of generalization. --[[User:Short Circuit|Michael Mol]] 14:35, 7 July 2011 (UTC)
:::::If that's the intent then it needs to be specified better and possibly moved so that the intention is better conveyed (I'm thinking [[Non-decimal radices/Convert/Binary]]). Since [[Non-decimal radices/Output]] doesn't offer much in the way of customization (since the task is to let the language do it), its binary examples would be directly copied to this task. So I think we should disallow those sorts of built-in functions. --[[User:Mwn3d|Mwn3d]] 14:45, 7 July 2011 (UTC)
::::::Possibly we could drop convert, and have Non-decimal radices/Binary, because this task does not necessarily involve conversion, but I think the name does not need changing here. The task is appropriately categorized. I suggest that we do not rename. [[User:Markhobley|Markhobley]] 15:56, 7 July 2011 (UTC)
:::::::For what it's worth: the J implementation of this task is all about conversion, and not at all about output (since implicit output was sufficient).  Furthermore, in the general context of computer engineering, "binary output" typically means something very different from what this task asks for (and is typically machine specific and not general to all the platforms supported by a language unless the language itself only has implementations for one machine architecture). I do not have any specific suggestions to resolve these issues, but I do not think that these issues should be disregarded when considering other suggestions. --[[User:Rdm|Rdm]] 16:50, 7 July 2011 (UTC)
::::::::"Binary digits" refers specifically to set of digits consisting of 0 and 1. [[User:Markhobley|Markhobley]] 17:02, 7 July 2011 (UTC)
:::::::I think we need some terminology clarification here because you seem to be using some words differently than other people. "Native" means "built in to the language" when you say it, right (see [[wp:Native#Computing]] for what other people may be thinking)? Is the Java example of Integer.toBinaryString native? I can't tell what you mean when you say "conversion". Do you mean "changed to a different number"? Do you mean "changed to a different type"? I'm unclear on what "conversion" entails. --[[User:Mwn3d|Mwn3d]] 17:43, 7 July 2011 (UTC)
::::::::Native:Yes, it means "built in to the language".
::::::::Conversion:A number crunching or string manipulation routine needs to be utilized to achieve this goal
::::::::[[User:Markhobley|Markhobley]] 18:18, 7 July 2011 (UTC)

==A mess?==
The task description is a mess.  The task giver uses words like "decimal number", "digits" and "conversion" way too liberally.  From what explanations are given on this page, the task should be better described as: take an integer, and write out a string consisting of 0s and 1s that represent the number in base 2.  And the claim "some languages don't require conversion" is bunk, again due to the lack of clear definition of the words involved. --[[User:Ledrug|Ledrug]] 23:55, 7 July 2011 (UTC)

:I used the term "decimal integer", which I thought was straightforward. The intention was to provide a function or procedure that takes a decimal integer and outputs the binary digits. For example: print tobinary(5) gives output 101, where 5 is a decimal value, and the output would be 101 in binary digits. The word "decimal" here is to indicate that the input value is in base 10. I don't know why "digits" is causing confusion. The word "conversion" does not appear in the task description. [[User:Markhobley|Markhobley]] 19:04, 8 July 2011 (UTC)
::There are three distinct entities here.  The input text is "5", and is a decimal representation of a number.  In many languages, this is deserialized to an internal representation of a number (and this internal representation is binary).  The result of tobinary() would then take this binary number and produces output text which is "101".  There are some exceptions to this overview (snobol4, bash and m4 might all be exceptions).  But, in the typical case tobinary() takes a binary number argument and produces a textual result (and in the exceptional cases it is still producing a textual result).  --[[User:Rdm|Rdm]] 20:38, 8 July 2011 (UTC)
:::Ah right. I would tend to refer to the argument as numerical, rather than binary in this case. By binary, I mean the base two numbering system. The argument is not really binary, if it is not in base two. (I am talking at input level, not cpu level here.) [[User:Markhobley|Markhobley]] 21:20, 8 July 2011 (UTC)
::::But neither output text nor internal numbers are inputs in and of themselves (though either of them can be, with appropriate external interfaces).  So this is a meaningless distinction without additional unspecified structure. --[[User:Rdm|Rdm]] 22:39, 8 July 2011 (UTC)
:::::"The task is to output the sequence of binary digits for a given non negative decimal integer." - The word "given" here means supplied as input (this can be parametric input to the conversion routine, rather than user input), but I think that is splitting hairs. The task description looks fine to me. [[User:Markhobley|Markhobley]] 23:16, 8 July 2011 (UTC)

: It is hard to get a task description correct. The descriptions given might have needed some polish, but was a long way from being an outright mess, and could, and has been, improved over time. Tone can be very hard to convey in such short paragraphs common to RC and people can fail to see an encouragement to improve when couched in ambiguous terms. (Ambiguous in the sense that is the intent to get someone ''else'' to improve the task description, or is it to belittle someone)?
:Cut the guy some slack and lets all muck-in to improve things? --[[User:Paddy3118|Paddy3118]] 08:03, 9 July 2011 (UTC)
:: It happens way too often: sometimes a task is given without fully understanding its complexity ([[Last letter-first letter]]), sometimes the task giver has a rather naive understanding of the question asked ([[Convert decimal number]]), and sometimes the task giver doesn't know what's involved at all ([[Colour pinstripe/Printer]], [[Pinstripe/Printer]]), all of which give a lot of confusion to people who try to provide example solutions.  Read through the comments on this page, and see how hazy the task giver's idea about "number", "digit", "number crunching" and "string" is.  Don't you think that's a little irresponsible? Confusion and lack of clarity lead to varying intepretations of tasks, resulting in code that's not correct or doing wildly different things -- do you care about the content on this wiki, or is it enough just being nice and fuzzy while cutting everyone some slack? --[[User:Ledrug|Ledrug]] 08:59, 9 July 2011 (UTC)
:::It's a wiki. Just try and fix what you can. [[User:Markhobley|Markhobley]] 09:22, 9 July 2011 (UTC)
:::FWIW I have exact ideas about what "number", "digit", "number crunching", and "strings" are. To me, these are not hazy at all. It's just that my ideas do not necessarily match other people's ideas. :) Admittedly, I don't know a lot about printing, but rosetta code is teaching me some things here, and I can use google, so I will learn how to print.

:::Nice and fuzzy? No, nice and precise! I'm sure that there may well be other ways to get to precise, but being nice makes the journey more enjoyable.  --[[User:Paddy3118|Paddy3118]] 10:12, 9 July 2011 (UTC)

== Natural numbers ==
The task description now reads "natural numbers". Do we all agree that natural numbers are integers greater than or equal to zero? Or is this another source of confusion? [[User:Markhobley|Markhobley]] 09:22, 9 July 2011 (UTC)

:Any question about zero from the wp link description shouldn't really matter for the purposes of this task. What does matter are that it ''doesn't'' include negative numbers with absolute value greater than zero. I'm sure someone could pick holes in this if they tried, but I think the clarification in the linked text should be OK for the purposes of the task. (But then I did add the link). --[[User:Paddy3118|Paddy3118]] 10:20, 9 July 2011 (UTC)

:: I think the matter of zero is very important to this task as some of the example programs don't handle the case of zero correctly, in that some example programs remove ''all'' leading zeroes, and in the case of a value of zero, a "null" value is returned. Since almost all program examples don't show the case for zero, it's hard for casual readers of other languages to recognize that (if) the error exists in the code (of specifically handling a zero case).  I didn't flag those program examples as '''incorrect''' as I don't have a definitive way of proving my observations. It's a trivial case, but still important. Rockets blowing up, anyone? -- [[User:Gerard Schildberger|Gerard Schildberger]] 18:53, 27 June 2012 (UTC)

::: I concur Gerard. examples should work for zero but it is hard to check if output for zero is not shown. --[[User:Paddy3118|Paddy3118]] 20:33, 27 June 2012 (UTC)

:::: Yes, indeedy.  I previously hurriedly added the special case of zero to the two REXX versions (to at least ''practice what I preach'').  What prompted my comment above was that the '''NETREXX''' version had an error in it, but I couldn't verify that as I don't have a NetRexx interpreter.  I'm 99% sure of the error, but I wouldn't want to bet my life on it and flag an example as incorrect just on my ''understanding'' of that language (and not its execution). -- [[User:Gerard Schildberger|Gerard Schildberger]] 20:43, 27 June 2012 (UTC)

== Task review process ==

Would it help for us to have a more structured process for getting tasks from draft to non-draft status? I can see, laterly, that part of the problem with the existing routine is lack of reasonably rapid attention and/or interest when new draft tasks are added. If there's interest, we can implement something. Right now, I've got a consensus-based approach with a minimum-required level of feedback in mind. (i.e. each task would need at least two or three people's input, if only a "looks good to me," and would need to incubate a minimum amount of time) --[[User:Short Circuit|Michael Mol]] 10:29, 9 July 2011 (UTC)

:I don't think we need to go over the top. We want to incourage innovation and development, not stifle it. Some tasks are more interesting than others, so some tasks may not have high traffic. It is a wiki, so contributors can always add and update the tasks. There may be some developers who are only looking at the non-draft tasks, so the drafts are just not getting attention. I don't think we should make the process more difficult than what it is and we don't want to lose skilled writers because of restrictive policies. We could have a 30 day incubation period to enable tasks to evolve, but I think that is the extent of what we should be doing. [[User:Markhobley|Markhobley]] 14:31, 9 July 2011 (UTC)
